---
layout: single
title:  "웹 MVC 스터디 후기"
categories: "스터디"
tag: [Kerenel360, 스터디, web MVC, 스프링, thread pool, reflection, servlet, dispatcher servlet, was]
---

# 소감
먼저 다른 분들(소현님, 현준님, 호윤님)이 정말 열심히 준비하셨다는 생각이 드는 동시에, 강의는 여러 번 들었으나 스터디를 통해 나의 언어로 스스로 정리하지 않았다는 생각이 들어 반성이 많이 되었다.

오늘의 스터디를 통해 몰랐던 부분과 잘 표현하지 못했던 부분을 추가로 조사하고 다시 잊지 않기 위해, 또는 언제든 다시 찾아서 바로 이해하고 설명할 수 있도록 기록으로 남기기로 했다.

<details>
<summary>왜 Single이 아닌 multi-thread로 웹서버를 만드나?</summary>

<!-- summary 아래 한칸 공백 두어야함 -->
단일 쓰레드로 웹 서버를 만들면 클라이언트의 요청이 2개 이상이면 하나를 처리하는 동안 다른 요청은 기다려야 한다. 때문에 다수의 처리를 빠른 시간에 응답해야 하는 웹 서버에서 단일 쓰레드로 요청을 처리하는 것은 매우 비효율적이다.

    1. 동시성 처리:
    - 다수의 클라이언트가 동시에 서버에 요청을 보낼 수 있는 현대의 웹 환경에서는 동시성 처리가 필수적입니다. 멀티쓰레드로 웹 서버를 만들면 여러 클라이언트의 요청을 동시에 처리할 수 있으므로 응답 시간을 최적화할 수 있습니다.

    2. I/O 대기 시간 감소:
    - 네트워크 작업이나 파일 입출력과 같은 I/O 작업이 있는 경우, 단일 쓰레드에서는 한 작업이 완료될 때까지 다음 작업을 수행할 수 없습니다. 멀티쓰레드로 구현하면 한 쓰레드가 I/O 작업을 수행하는 동안 다른 쓰레드가 다른 작업을 처리할 수 있어 대기 시간을 최소화할 수 있습니다.

    3. 성능 및 확장성 향상:
    - 멀티쓰레드로 웹 서버를 만들면 여러 코어를 활용하여 병렬적으로 작업을 수행할 수 있어 전체적인 성능이 향상될 수 있습니다. 또한, 서버의 부하 증가에 따라 필요에 따라 쓰레드 풀의 크기를 동적으로 조절하면서 확장성을 확보할 수 있습니다.

    4. 비동기 처리:
    - 멀티쓰레드 환경에서는 비동기 처리를 통해 더 효율적으로 리소스를 활용할 수 있습니다. 비동기 방식은 하나의 쓰레드가 여러 작업을 동시에 처리할 수 있도록 지원하며, 이는 대규모 웹 서비스에서 효과적입니다.
    5. Deadlock 및 성능 문제 감소:
    - 멀티쓰레드로 웹 서버를 구현하면 단일 쓰레드에서 발생할 수 있는 데드락과 같은 문제를 피할 수 있습니다. 또한, 여러 쓰레드 간의 작업 분배로 인해 성능이 떨어지는 상황을 개선할 수 있습니다.
    종합적으로 멀티쓰레드로 웹 서버를 만드는 이유는 효율적인 자원 활용, 동시성 처리, 대용량 트래픽에 대한 대응, 확장성 등 다양한 측면에서 성능을 향상시킬 수 있기 때문입니다.
</details>


<details>
<summary>Thread pool을 왜 만들었나?</summary>

> thread를 만드는 비용도 많이 소모되고 쓰레드를 무한정 만들면 오히려 성능에 부담이 되는 경우가 생긴다. 때문에 모니터링을 통해 `가장 좋은 성능을 내는 쓰레드 수를 알아내고 해당 쓰레드만큼 미리 할당`을 해 놓으면 요청에 따라 가용한 쓰레드만큼 서비스를 제공하여 최적의 성능을 보장할 수 있다

1. 쓰레드 생성 비용과 부하 문제:
    ◦ 쓰레드를 생성하는 데는 상당한 비용이 들기 때문에, 많은 수의 쓰레드를 무한정 생성하는 것은 비효율적입니다. 이렇게 많은 쓰레드를 생성하면 운영체제의 자원을 많이 소비하게 되고, 쓰레드 간의 전환에 따른 부하도 증가할 수 있습니다. 특히, 짧은 수명의 작업이나 높은 빈도의 작업을 처리할 때 이 비용은 더 커집니다.
2. 쓰레드 풀의 역할:
    ◦ 쓰레드 풀은 쓰레드를 특정 개수만큼 미리 생성해두고, 작업이 발생하면 해당 쓰레드를 사용하여 처리합니다. 쓰레드 풀을 통해 쓰레드의 생성과 소멸 비용을 줄이고, 재사용성을 높여서 효율적인 작업을 처리할 수 있습니다.
3. 모니터링을 통한 최적의 쓰레드 수 동적 조절:
    ◦ 모니터링을 통해 시스템의 상태를 주시하고, 적절한 시점에 쓰레드 풀의 크기를 동적으로 조절함으로써 최적의 성능을 유지할 수 있습니다. 이는 시스템의 부하나 작업량에 따라 최적의 쓰레드 수를 동적으로 조절하여 자원을 효율적으로 사용하는 방식입니다.
요약하면, 쓰레드 풀은 쓰레드 생성 비용을 줄이고, 모니터링을 통해 동적으로 쓰레드의 수를 조절하여 최적의 성능을 유지하는데 사용됩니다.

</details>

<details>
<summary>Servlet이란?</summary>

### 어원
서버 + 애플릿으로 애플릿은 브라우저에서 실행되는 작은 애플리케이션을 말한다. 
### 정의
서블릿은 웹 애플리케이션의 구성 요소 중 하나로 동적인 페이지를 생성하고 처리하기 위한 JAVA클래스이다.
### 서블릿의 주요 특징과 역할

1. **라이프사이클 관리:**
    
    서블릿은 라이프사이클이라는 특정한 단계에 따라 초기화되고, 클라이언트의 요청에 대한 응답을 처리한 후 소멸됩니다. 이 라이프사이클은 `init()`, `service()`, `destroy()` 메서드 등을 통해 관리됩니다.
2. **HTTP 요청 처리:**

    주로 HTTP 프로토콜을 통해 클라이언트의 요청을 받아들이고, 그에 따른 동적인 콘텐츠를 생성하여 HTTP 응답을 생성합니다.
3. **멀티스레딩 지원:**

    각 클라이언트의 요청은 별도의 쓰레드에서 처리되므로, 여러 클라이언트의 동시 요청에 대응할 수 있습니다.
4. **세션 관리 및 데이터 공유:**

    서블릿은 세션을 통한 상태 관리를 지원하며, 서블릿 컨텍스트를 활용하여 서블릿 간에 데이터를 공유할 수 있습니다.
5. **웹 어플리케이션의 일부로 사용:**

    서블릿은 주로 JSP(JavaServer Pages)와 함께 사용되어 `동적인 웹 애플리케이션`을 개발하는 데 활용됩니다.
</details>

<details>
<summary> Dispatcher Servlet이란?</summary>

스프링 프렝임워크에서 사용되는 개념으로, 스프링의 웹 애플리케이션에서 클라이언트의 요청을 처리하고 적절한 핸들러(컨트롤러)에게 전달하는 역할을 합니다. 스프링 MVC에서 디스패처 서블릿은 클라이언트의 모든 요청을 받아들이고, 핸들러 매핑 및 핸들러 어댑터를 통해 적절한 컨트롤러에게 요청을 전달합니다.

여기서는 현준님의 설명이 기억에 남는다.
디스패처라는 뜻을 찾아보면 "발송하는 사람, 배차원" 등의 뜻이 있다. 또한 항공 분야에서는 비행 계획을 작성하고 비행 중인 항공기의 운항 상태를 감시하여 필요한 정보를 기장에게 전달하는 역할을 하는 사람을 뜻한다. 즉 일이나 정보를 전달하여 다른 사람이 행동하게 하는 사람을 나타내는 것으로 이해 됐다.

디스패처 서블릿은 디스패처 역할을 하는 서블릿으로 서블릿의 역할에 더해 핸들러 매퍼에 정보를 전달하여 적절한 컨트롤러(핸들러)를 찾게 하고, 그렇게 전달받은 핸들러를 어댑터엑레 전달헤 컨트롤러를 실행하게 하고 뷰를 전달 받는다. 전달받은 뷰를 또다시 뷰 리졸버에게 전달하여 클라이언트에게 전달할 페이지를 받아오는 역할을 하는 것 같다.

</details>

<details>
<summary> 서블릿과 디스패처 서블릿의 차이</summary>

1. **목적:**
- 서블릿은 Java EE 표준 스펙으로 웹 애플리케이션의 동적인 콘텐츠 생성 및 처리를 담당합니다. 디스패처 서블릿은 스프링에서 제공하는 웹 프레임워크(Spring MVC)에서 클라이언트의 요청을 관리하고 컨트롤러에 전달하는 역할을 합니다.
2. **프레임워크 종속성:**
- 서블릿은 Java EE 표준 스펙으로, 다양한 웹 애플리케이션 서버에서 사용할 수 있습니다. 반면에 디스패처 서블릿은 스프링 프레임워크에서만 사용되는 개념으로, 스프링 기반의 웹 애플리케이션에서만 의미가 있습니다.
3. **구조:**
- 서블릿은 주로 웹 컨테이너에 의해 직접 호출되어 사용됩니다. 반면에 디스패처 서블릿은 스프링 컨테이너에 의해 생성되고 관리되며, 스프링의 MVC 패턴에 기반하여 동작합니다.
4. **컨트롤러 전달:**
- 서블릿은 개발자가 직접 서블릿 클래스를 작성하고 매핑하여 요청을 처리합니다. 반면에 디스패처 서블릿은 핸들러 매핑과 핸들러 어댑터를 사용하여 컨트롤러에게 요청을 전달하므로 개발자는 컨트롤러에 집중할 수 있습니다.

서블릿은 자바 웹 개발에서의 기본 요소이며, 디스패처 서블릿은 스프링의 웹 프레임워크에서 클라이언트의 요청을 효과적으로 관리하고 컨트롤러에 전달하기 위한 고수준의 개념입니다.

</details>

<details>
<summary>WAS(Web application Server)란?</summary>

WAS는 웹 애플리케이션을 실행하기 위한 특화된 서버로 정적인 콘텐츠 뿐만 아니라 동적인 콘텐츠도 처리할 수 있다. 주로 웹 애플리케이션의 실행 환경을 제공하고 관리한다.


</details>
<details>
<summary>WAS의 역할은?</summary>

1. 서블릿 컨테이너 및 JSP 컨테이너:

    WAS는 서블릿 컨테이너와 JSP 컨테이너를 내장하고 있습니다. 이 컨테이너들은 자바 웹 애플리케이션의 실행을 담당하며, 서블릿과 JSP를 실행시켜 동적인 웹 콘텐츠를 생성합니다.
2. 커넥션 풀링 및 트랜잭션 관리:

    데이터베이스와의 연결 관리, 트랜잭션 처리, 성능 최적화를 위한 커넥션 풀링 등을 제공하여 데이터베이스와의 효율적인 상호작용을 지원합니다.
3. 클러스터링 및 부하 분산:

    다수의 WAS 인스턴스를 클러스터로 구성하여 부하 분산을 구현할 수 있습니다. 이는 웹 애플리케이션의 가용성과 성능을 향상시키는 데 도움이 됩니다.
4. 보안 및 인증:

    보안 기능을 제공하고, 사용자 인증 및 권한 부여를 처리하여 웹 애플리케이션의 안전성을 강화합니다.
5. 웹 서비스 지원:

    다양한 프로토콜을 지원하며, 웹 서비스를 구현하고 실행하는 데 필요한 도구 및 환경을 제공합니다.
6. 스레드 풀 및 메모리 관리:

    서버의 자원을 효과적으로 관리하기 위해 스레드 풀과 메모리 관리 기능을 제공합니다.

</details>

<details>
<summary> 웹 서버와 WAS 비교</summary>

### WAS와 웹 서버 간의 차이:

1. 목적:

    웹 서버는 정적인 콘텐츠(HTML, 이미지 파일 등)를 처리하고, 클라이언트로부터 HTTP 요청을 받아 정적인 리소스를 제공합니다. 반면에 WAS는 동적인 콘텐츠를 처리하고, 서블릿과 JSP 같은 자바 기반의 코드를 실행하여 동적인 웹 페이지를 생성합니다.

2. 동적 콘텐츠 처리:

    웹 서버는 주로 정적인 콘텐츠를 처리하는 데에 특화되어 있으며, 동적인 처리는 WAS에게 위임됩니다. WAS는 동적인 콘텐츠를 생성하고, 그 결과를 웹 서버에게 전달하여 클라이언트에게 제공합니다.

3. 서블릿 컨테이너:

    웹 서버는 서블릿 컨테이너를 내장하지 않고, 동적인 처리를 위해 서블릿 컨테이너를 사용하는 WAS에게 요청을 전달합니다.

4. 프로토콜 지원:

    웹 서버는 주로 HTTP와 HTTPS 프로토콜을 지원하며, 정적인 콘텐츠를 제공합니다. 반면에 WAS는 다양한 프로토콜을 지원하고, 동적인 콘텐츠를 생성하여 클라이언트에게 제공합니다.

5. 단독 서버 vs. 다중 서버:

    웹 서버는 주로 단독으로 사용되며, 정적인 콘텐츠를 처리하는 데 중점을 둡니다. 보통 정적인 파일들을 처리하고 클라이언트로 전송하는 역할을 수행합니다. 대표적인 웹 서버로는 Apache, Nginx가 있습니다.

    WAS는 동적인 콘텐츠를 처리하고, 데이터베이스와의 상호작용, 비즈니스 로직 실행 등의 업무를 담당합니다. WAS는 더 많은 기능과 자원을 필요로 하기 때문에, 여러 WAS 인스턴스를 클러스터로 구성하여 부하 분산 및 고가용성을 확보하는 경우가 많습니다. WAS의 대표적인 예로는 Apache Tomcat, JBoss, WebSphere 등이 있습니다.

    웹 서버와 WAS는 종종 협력하여 하나의 시스템을 구성하기도 합니다. 웹 서버는 정적인 콘텐츠를 처리하고, 동적인 처리는 WAS에게 위임하여 나누어 처리함으로써 성능 및 효율성을 극대화합니다. 이러한 구성은 대형 웹 애플리케이션에서 흔히 볼 수 있는 아키텍처입니다.

    종합적으로, 웹 서버와 WAS는 각각의 목적과 역할에 따라 사용되며, 현대의 웹 애플리케이션에서는 두 서버가 협력하여 동적인 콘텐츠와 정적인 콘텐츠를 효율적으로 처리하는 구성이 일반적입니다.
</details>


<details>
<summary> Handler Adapter가 다양한 컨트롤러 유형을 표준화된 방식으로 처리하여 사용자가 새로운 유형의 컨트롤러를 추가하거나 기존의 컨트롤러를 확장하는 데 유연성을 제공하는데 어떤 개념들이 사용되었을까?</summary>


1. 인터페이스 기반 프로그래밍 (Interface-Based Programming):

    각 컨트롤러 유형을 특정한 인터페이스로 정의하고, Handler Adapter가 해당 인터페이스를 구현하도록 함으로써, 컨트롤러의 일관된 처리를 가능케 합니다. 인터페이스는 특정한 동작이나 기능을 추상화하고 정의하는 데에 사용되며, 이를 통해 다형성을 활용할 수 있습니다.

2. 전략 패턴 (Strategy Pattern):

    각 컨트롤러 유형을 처리하는 전략을 개별적으로 구현하고, Handler Adapter는 이러한 전략을 동적으로 선택하여 사용합니다. 이를 통해 특정 컨트롤러 유형에 대한 처리 로직을 변경하거나 추가하는 데 용이합니다.

3. 팩토리 메서드 패턴 (Factory Method Pattern):

    Handler Adapter를 생성하는 데에 팩토리 메서드 패턴을 활용할 수 있습니다. 각 컨트롤러 유형에 대한 Handler Adapter를 생성하는 별도의 팩토리 메서드를 정의하고, 팩토리는 인터페이스를 통해 Handler Adapter를 생성합니다.

4. 의존성 주입 (Dependency Injection):

    컨트롤러와 Handler Adapter 간의 의존성을 주입함으로써, 런타임 시에 다양한 컨트롤러 유형에 대응할 수 있습니다. 스프링은 의존성 주입을 통해 객체 간의 결합도를 낮추고, 확장성을 높이는 데에 기여합니다.

5. 컨텍스트 관리 (Context Management):

    Handler Adapter는 실행 컨텍스트에 대한 정보를 관리하여 어떤 컨트롤러 유형을 어떻게 처리할지 결정합니다. 컨텍스트 관리를 통해 다양한 유형의 컨트롤러를 일관된 방식으로 처리할 수 있습니다.

6. 템플릿 메서드 패턴 (Template Method Pattern):

    Handler Adapter는 각 컨트롤러 유형에 대한 처리의 일부를 템플릿 메서드로 정의하고, 실제 처리는 하위 클래스에서 구현하도록 합니다. 이를 통해 전체적인 흐름은 일관되게 유지하면서 특정 부분을 하위 클래스에서 다르게 구현할 수 있습니다.

이러한 원칙과 패턴들을 적절히 조합하여 다양한 컨트롤러 유형을 효과적으로 처리하고 확장 가능한 시스템을 구축할 수 있습니다. 이는 객체지향 프로그래밍과 소프트웨어 디자인 원칙을 활용한 좋은 소프트웨어 디자인의 예시입니다.

</details>

<details>
<summary> Annotation을 사용하는 이유</summary>

어노테이션(Annotation)은 자바 프로그래밍에서 코드에 부가적인 정보를 제공하는 메커니즘으로, 주석처럼 소스 코드에 추가되어 특별한 의미나 동작을 나타냅니다. 어노테이션을 사용하는 이유는 다양하며, 주요한 몇 가지 이유는 다음과 같습니다:

1. **코드에 메타데이터 추가:**

   어노테이션은 코드에 메타데이터를 부여할 수 있습니다. 메타데이터는 프로그램의 런타임 동작에 영향을 주거나, 컴파일 시에 특정한 작업을 수행하는 데 사용됩니다. 예를 들어, `@Override` 어노테이션은 메서드가 슈퍼클래스의 메서드를 오버라이드하고 있다는 것을 나타냅니다.

2. **컴파일러 경고 및 에러 감지:**

   어노테이션을 사용하면 컴파일러가 코드를 분석하고 특정 규칙을 적용할 수 있습니다. 예를 들어, 널 체크를 강제하는 어노테이션을 사용하면 컴파일러가 해당 메서드나 변수에서의 널 포인터 예외를 사전에 감지할 수 있습니다.

3. **런타임 처리 및 리플렉션 지원:**

   어노테이션은 런타임 시에도 정보를 제공하며, 리플렉션(Reflection)을 통해 프로그램이 자기 자신의 구조를 분석할 수 있게 합니다. 이는 프레임워크나 라이브러리에서 커스텀 동작을 정의하고 확장할 때 유용합니다.

4. **코드 문서화와 가독성 향상:**
   
   어노테이션은 코드에 추가적인 정보를 제공하므로, 코드를 이해하고 사용하는 데 도움이 됩니다. 예를 들어, `@Deprecated` 어노테이션은 해당 요소가 더 이상 권장되지 않음을 나타내어 사용자에게 경고를 줄 수 있습니다.

5. **프레임워크 지원 및 확장성:**
   
   많은 자바 프레임워크들은 어노테이션을 사용하여 특정 규약을 정의하고, 프로그래머가 이를 따르도록 유도합니다. 스프링 프레임워크의 `@Autowired`나 JPA의 `@Entity`와 같은 어노테이션은 프레임워크가 런타임 시에 특정 작업을 수행하도록 하는 데 사용됩니다.

6. **컴파일 타임 체크:**
   
   어노테이션을 사용하면 일부 체크를 컴파일 타임에 수행할 수 있습니다. 예를 들어, 롬복(Lombok)과 같은 라이브러리를 사용하면 코드를 간결하게 작성하면서도 컴파일러가 필요한 메서드들을 자동으로 생성할 수 있습니다.

7. **커스텀 마커 및 컴파일러 힌트:**
   
   어노테이션을 사용하여 특정 마커를 지정하거나, 컴파일러에게 추가적인 힌트를 제공할 수 있습니다. 이를 통해 도구나 프로세스에서 사용되는 정보를 포함할 수 있습니다.

어노테이션은 자바에서 강력한 기능을 제공하며, 코드의 가독성, 유지보수성, 그리고 확장성을 향상시키는 데에 기여합니다.

</details>

<details>
<summary>Dispatcher Servlet에서 Annotation을 사용하는 이유 </summary>

디스패처 서블릿(DispatcherServlet)은 스프링 MVC에서 클라이언트의 요청을 처리하고 컨트롤러에게 전달하는 핵심 컴포넌트입니다. 어노테이션은 디스패처 서블릿에서 여러 가지 목적으로 사용됩니다:

1. **컨트롤러의 식별과 매핑:**
   
   `@Controller` 어노테이션은 스프링에게 해당 클래스가 컨트롤러임을 알려줍니다. 디스패처 서블릿은 이 어노테이션을 참조하여 어떤 클래스가 컨트롤러로 동작할지 식별하고 매핑합니다.

2. **요청 매핑 및 핸들러 식별:**
   
   `@RequestMapping` 어노테이션은 메서드나 클래스에 부여되어 특정 URL에 대한 매핑을 정의합니다. 디스패처 서블릿은 클라이언트의 요청 URL과 매핑된 컨트롤러의 메서드를 찾아서 실행합니다.

3. **컨트롤러의 빈 등록:**
   
   `@Controller` 어노테이션이 부여된 클래스는 스프링의 컨테이너에 빈으로 등록됩니다. 디스패처 서블릿은 이 등록된 빈을 찾아서 사용하게 됩니다.

4. **모델-뷰-컨트롤러 (MVC) 패턴 구현:**
   
   디스패처 서블릿은 `@Controller` 어노테이션이 부여된 클래스를 기반으로 스프링 MVC의 MVC 패턴을 구현합니다. 이 패턴은 모델의 상태를 변경하는 컨트롤러, 모델의 표현을 담당하는 뷰, 그리고 사용자 인터페이스와 상호작용하는 모델로 구성됩니다.

5. **컨트롤러의 메서드 매개변수와 반환값 처리:**
   
   어노테이션을 사용하여 컨트롤러의 메서드 매개변수에 요청 파라미터를 바인딩하거나, 반환값을 특정 뷰로 전달할 수 있습니다. 예를 들어, `@RequestParam` 어노테이션을 사용하여 요청 파라미터를 메서드 매개변수에 주입할 수 있습니다.

6. **다양한 어노테이션 기반 기능 활용:**
   
   디스패처 서블릿은 `@ResponseBody`, `@ResponseStatus`, `@ModelAttribute` 등 다양한 어노테이션을 활용하여 응답의 상태 코드, 응답 본문 형식, 모델에 추가할 속성 등을 정의합니다.

7. **컨트롤러의 라이프사이클 관리:**
   
   `@Controller` 어노테이션이 부여된 클래스는 스프링의 IoC 컨테이너에서 라이프사이클을 관리합니다. 디스패처 서블릿은 이 라이프사이클을 통해 필요한 초기화나 종료 작업을 수행할 수 있습니다.

요약적으로, 어노테이션은 디스패처 서블릿에서 컨트롤러의 식별, 매핑, 라이프사이클 관리, MVC 패턴의 구현, 요청 매핑, 핸들러 식별, 매개변수 및 반환값 처리 등 다양한 측면에서 중요한 역할을 합니다. 이를 통해 스프링 MVC는 간편하고 유연한 웹 애플리케이션 개발이 가능해집니다.

</details>


<details>
<summary>
아래 코드에서 UserService가 주입되는 내부 과정을 설명해봅시다.

    @Controller
    public class UserController {

        private UserService userService;

        @Inject
        public UserController(UserService userService) {
            this.userService = userService;
        }

        public UserService getUserService() {
            return userService;
        }
    }
</summary>

물론이죠! 앞서 제공한 `BeanFactory`를 사용하는 `UserController` 클래스에서 `UserService`가 어떻게 주입되는지 다시 설명해보겠습니다.

1. **BeanFactory 생성:**
   - 먼저, `BeanFactory` 객체가 생성됩니다. 이 때 생성자를 통해 `preInstantiatedBeans`라는 미리 인스턴스화된 빈들의 집합이 주어집니다.

2. **BeanFactory 초기화:**
   - `initialize()` 메서드가 호출되어 `preInstantiatedBeans`에 속한 빈들을 생성하고 맵에 등록합니다.

3. **UserController 객체 생성:**
   - `preInstantiatedBeans`에 `UserController` 클래스가 포함되어 있으므로, 해당 클래스의 빈이 생성됩니다. 이때 생성자를 통해 `UserService` 빈이 주입됩니다.

4. **UserService 빈 주입:**
   - `UserController` 클래스의 생성자에 `@Inject` 어노테이션이 부여되어 있으므로, `BeanFactory`는 해당 생성자를 통해 `UserService` 빈을 주입합니다.
   - `UserService` 클래스의 빈은 미리 생성되어 맵에 등록되어 있으므로, 해당 인스턴스를 생성자를 통해 가져와서 주입합니다.

5. **UserController 객체 초기화:**
   - `UserController` 객체가 생성되고 `UserService` 빈이 주입되면, 이제 `UserController`의 인스턴스 변수 `userService`에는 주입된 `UserService` 빈이 할당됩니다.

6. **getUserService 메서드 호출:**
   - `getUserService` 메서드를 호출하면, 주입된 `UserService` 빈이 반환됩니다.

이렇게 빈 팩토리를 사용하여 의존성 주입이 이루어지면, `UserController`는 외부에서 생성된 `UserService` 빈을 주입받아 사용할 수 있게 됩니다. 이는 코드의 확장성과 유지보수성을 향상시키는데 도움이 됩니다.

</details>